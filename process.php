<?php
	//Google Maps API key is needed to retireve elevation data
	//For more info, see https://developers.google.com/maps/documentation/elevation/start
	$google_api_key = $_ENV["MAPS_API_KEY"];;
	$metadata = array();
	$destinations = array();
	
	//Read metadata from attached JPGs. Probabaly a cleaner way to do this, but it works.
	//No need to read in the entire file - first 4K should be enough for anyone
	foreach($_FILES['destinations']['name'] as $idx => $name)
	{
		$file_raw = file_get_contents($_FILES['destinations']['tmp_name'][$idx], NULL, NULL , 0, 4000);
		if(preg_match('/SerializedMetadata=\"(.+?)\"/',$file_raw, $x))
			$metadata[$name] = base64_decode($x[1]);
	}
	
	if(count($metadata) == 0)
		die('No location metadata found');
	$loc_str = "";
	
	//Extract longitude/latitude/scale values
	//Ideally we would extract 'elevation' too. Also an appropriate 'name' and 'description'.
	foreach($metadata as $name => $data)
	{
		$lat = unpack("d", substr($data, (strlen($data) - 92), 8));
		$long = unpack("d", substr($data, (strlen($data) - 83), 8));
		$scale = unpack("d", substr($data, (strlen($data) - 25), 8));
		
		$destinations[$name] = array('lat' => $lat[1], 'long' => $long[1], 'scale' => $scale[1]);
		//Build a request string for elevation data
		if(strlen($loc_str) == 0)
			$loc_str .= $lat[1] . "," . $long[1];
		else
			$loc_str .= "|" . $lat[1] . "," . $long[1];
	}
	if(count($destinations) == 0)
		die('No destinations found');
	
	//Workaround for retrieving elevation data
	$elev_json = json_decode(file_get_contents("https://maps.googleapis.com/maps/api/elevation/json?locations=" . $loc_str . "&key=" . $google_api_key), TRUE);
	
	if($elev_json['status'] != "OK")
		die('Unable to fetch elevation data');
	
	//Apply elevation data
	foreach($elev_json['results'] as $result)
	{
		foreach($destinations as $name => $destination)
		{	
			if(abs($destination['lat'] - $result['location']['lat']) < 0.00000000001 && abs($destination['long'] - $result['location']['lng']) < 0.00000000001)
				$destinations[$name] = array('lat' => $destination['lat'], 'long' => $destination['long'], 'scale' => $destination['scale'], 'elevation' => $result['elevation']);
		}	
	}
	//Quick and easy way of allowing tour order to be customised: sort by filename
	ksort($destinations);
	
	//Generate the tour file itself
	$out = "name: \"" . $_POST['tourname']  . "\"\r\n\r\n";             //Tour name to show in the main menu
	$out .= "#Generated by https://earthvr-custom-tours.appspot.com/
#Include a file named 'bgaudio1.ogg' if you want a looping audio track
audio_resource: {
  name: \"BGAUDIO1\"
  audio_path: \"bgaudio1.ogg\"
  audio_type: DIRECT_STEREO
}
";
$out .= "sound_keyframes: {
  timestamp_seconds: 0
  name: \"BGAUDIO1\"
  sound_action: PLAY_LOOPING
}
";
	
	$x = 0;
	$total = count($destinations);
	foreach($destinations as $name => $destination)
	{
		//To keep things simple we estimate the desired start/end times (in UTC) based on longitude.
		//For approximate global consistency we use the date of the March equinox
		$init_time = round(($_POST['init_time'] - (($destination['long'])/180) * 12));
		$end_time = round(($_POST['end_time'] - (($destination['long'])/180) * 12));
		
		
		if($init_time >= 24)
		{
			$init_time = $init_time - 24;
			$init_day = 20;
		}
		else
			$init_day = 19;
		
		if($end_time >= 24)
		{
			$end_time = $end_time - 24;
			$end_day = 20;
		}
		else
			$end_day = 19;
		
		$out .= "# " . $name . "
sound_keyframes: {
  timestamp_seconds: " . ($x * $_POST['delay']) ."
  name: \"DSTAUDIO_" . trim($name,'.jpg') . "\"
  sound_action: PLAY_LOOPING
}
#'name' and 'description' are the top and bottom lines of text respectively on the globe controller (left hand)
#Could probably pull some appropriate default values from the jpg metadata
view_keyframes:{
	timestamp_seconds: " . ($x * $_POST['delay']) . "
	view:{
		location:{
			latitude: " . $destination['lat'] . " 
			longitude: " . $destination['long'] . " 
			altitude: " . $destination['elevation'] . "
		}
		anchor_point:{
			x: 0
			y: 0
			z: 0
		}
		heading: 0
		reference_space: ACTOR_FLOOR_SPACE
		viewer_scale: " . $destination['scale'] . "
		up_direction: SKY
	}
	name: \"" .  str_replace('_', ' ', trim($name, '.jpg')) ."\"
	#description: \"" . ($x + 1) . ' of ' . $total ."\"
}
#Include a file named '" . trim($name,'.jpg') . ".ogg' if you want audio there
audio_resource: {
  name: \"DSTAUDIO_" . trim($name,'.jpg') . "\"
  audio_path: \"" . trim($name,'.jpg') . ".ogg\"
  audio_type: DIRECT_STEREO
}
	
simulation_time_keyframes: {
	timestamp_seconds: " . ($x * $_POST['delay']) . "
	simulation_time:{
		year: 2016
		month: 3
		day: " . $init_day . "
		hour: " . $init_time . "
		minute: 0
		second: 0
	}
	type: FIXED_PLANET
}
simulation_time_keyframes: {
	timestamp_seconds: " . (($x + 1) * $_POST['delay']) . "
	simulation_time:{
		year: 2016
		month: 3
		day: " . $end_day . "
		hour: " . $end_time . "
		minute: 0
		second: 0
	}
	type: FIXED_PLANET
}
	
";
	//Don't include a fadein on the first location as its not required
	if($x > 0)
{
	$out .= "
screen_fade_keyframes:{
	timestamp_seconds: " . (($x * $_POST['delay']) + 0.5) . "
	opacity: 0.0
}
screen_fade_keyframes:{
	timestamp_seconds: " . (($x * $_POST['delay']) + 1.0) . "
	opacity: 1.0
}
";
}
	//Fadeouts arent required on the last location either
	if($x < ($total - 1))
{
	$out .= "
screen_fade_keyframes:{
	timestamp_seconds: " . ((($x + 1) * $_POST['delay']) - 0.5) . "
	opacity: 1.0
}
screen_fade_keyframes:{
	timestamp_seconds: " . (($x + 1) * $_POST['delay']) . "
	opacity: 0.0
}
	
";
}
    //Stop playing any location specific audio
    $out .= "sound_keyframes: {
  timestamp_seconds: " . (($x + 1) * $_POST['delay']) ."
  name: \"DSTAUDIO_" . trim($name,'.jpg') . "\"
  sound_action: STOP
}
";
	$x++;
	}

	//Stop the background audio track
	$out .= "sound_keyframes: {
  timestamp_seconds: " . ($x * $_POST['delay']) . "
  name: \"BGAUDIO1\"
  sound_action: STOP
}	
";
		
	//Output tour file
	header("Content-Description: File Transfer"); 
	header("Content-Type: application/octet-stream"); 
	header("Content-Disposition: attachment; filename=earthVR.textpb"); 
	
	print $out;
	
?>